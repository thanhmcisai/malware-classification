from typing import Any

import time
import pickle
import numpy as np
import keras_tuner as kt
from sklearn.metrics import roc_curve, auc
import matplotlib
# matplotlib.use('Agg')
import matplotlib.pyplot as plt
from fastapi import FastAPI, UploadFile, File
from gensim.models.doc2vec import Doc2Vec

from train import create_mlp_model
from test_r2pipe import load_opcode_from_binary_file

app = FastAPI()

embedding_model = Doc2Vec.load("d2v_model.model")

# Create tuner for load mlp model
tuner = kt.Hyperband(
    create_mlp_model,
    objective='val_accuracy',
    max_epochs=20,
    factor=3,
    directory='results',
    project_name='malware-classify-mlp'
)
# Get best mlp model
best_models = tuner.get_best_models(num_models=1)
malware_classify_model = best_models[0]

print(malware_classify_model.summary())

# Get the optimal hyperparameters
best_hps = tuner.get_best_hyperparameters(num_trials=1)[0]

print(f"""
The hyperparameter search is complete. The optimal number MLP layers are {best_hps.get('num_layers')}, number of units in the densely-connected layer is {best_hps.get('units')} and the optimal learning rate for the optimizer is {best_hps.get('learning_rate')}.
""")

# Load test
X_test = pickle.load(open("X_test.npy", "rb"))
y_test = pickle.load(open("y_test.npy", "rb"))
print("Data size", len(X_test))


def plot_roc_curve(true_y, y_prob):
    """
    plots the roc curve based of the probabilities
    """
    beggin_fpr, beggin_tpr, _ = roc_curve(true_y.argmin(axis=1), y_prob[:, 0])
    beggin_auc = auc(beggin_fpr, beggin_tpr)
    malware_fpr, malware_tpr, _ = roc_curve(true_y.argmax(axis=1), y_prob[:, 1])
    malware_auc = auc(malware_fpr, malware_tpr)
    plt.title('Receiver Operating Characteristic - MLP')
    plt.plot(beggin_fpr, beggin_tpr, label=f"ROC curve for Beggin (AUC = {round(beggin_auc, 2)})")
    plt.plot(malware_fpr, malware_tpr, label=f"ROC curve for Malware (AUC = {round(malware_auc, 2)})")
    plt.plot([0, 1], ls="--")
    plt.plot([0, 0], [1, 0], c=".7"), plt.plot([1, 1], c=".7")
    plt.axis("square")
    plt.xlabel('False Positive Rate')
    plt.ylabel('True Positive Rate')
    plt.legend()
    plt.show()


# Evaluate and calculate
start_time = time.time()
results = malware_classify_model.evaluate(X_test, y_test, batch_size=32)
y_pred = malware_classify_model.predict(X_test, batch_size=32)
plot_roc_curve(y_test, y_pred)

process_time = time.time() - start_time
print("Time consume:", process_time)
print("Time consume per request:", process_time / len(X_test))
print("test loss, test acc:", results)


@app.post("/predict/")
async def predict(file: UploadFile = File(...)) -> Any:
    file_location = f"files/{file.filename}"
    with open(file_location, "wb+") as file_object:
        file_object.write(file.file.read())

    # Load opcode using radare2
    opcode_word_list, opcode_list = load_opcode_from_binary_file(file_location)

    # Embedding opcode
    embedding_file = embedding_model.infer_vector(doc_words=opcode_word_list, epochs=100, alpha=0.025)

    # Classify malware
    malware_predict = malware_classify_model.predict(np.expand_dims(embedding_file, axis=0), verbose=0)

    return {
        "filename": file.filename,
        "opcode_list": opcode_list,
        "prediction": {
            "beggin": malware_predict[0][0] * 100,
            "malware": malware_predict[0][1] * 100
        }
    }
